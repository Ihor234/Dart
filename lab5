import 'dart:async';

class Lecture {
  String _date;
  String _topic;
  int _studentCount;
  Lecture(this._date, this._topic, this._studentCount);
  String get date => _date;
  String get topic => _topic;
  int get studentCount => _studentCount;
  set date(String value) => _date = value;
  set topic(String value) => _topic = value;
  set studentCount(int value) => _studentCount = value;
  @override
  String toString() {
    return 'Лекція: "$_topic" ($_date), кількість студентів: $_studentCount';
  }
}

class Container<T> {
  List<T> items = [];
  void addItem(T item) => items.add(item);

  // Generic-метод для пошуку мінімального елемента
  T? findMinBy<R extends Comparable>(R Function(T) selector) {
    if (items.isEmpty) return null;
    items.sort((a, b) => selector(a).compareTo(selector(b)));
    return items.first;
  }

  // Generic-метод для фільтрації елементів
  List<T> filter(bool Function(T) predicate) {
    return items.where(predicate).toList();
  }

  // Future з використанням Future.value
  Future<T?> findMinByAsyncValue<R extends Comparable>(
      R Function(T) selector) {
    try {
      T? result = findMinBy(selector);
      return Future.value(result);
    } catch (e) {
      return Future.error(e);
    }
  }

  // Future з використанням Future(() => ...)
  Future<List<T>> filterAsync(bool Function(T) predicate) {
    return Future(() {
      try {
        return filter(predicate);
      } catch (e) {
        throw e;
      }
    });
  }
}

class Course {
  String _courseName;
  String _teacherSurname;
  Container<Lecture> lectures = Container<Lecture>();
  Course(this._courseName, this._teacherSurname);
  String get courseName => _courseName;
  String get teacherSurname => _teacherSurname;
  set courseName(String value) => _courseName = value;
  set teacherSurname(String value) => _teacherSurname = value;
  void addLecture(Lecture lecture) {
    lectures.addItem(lecture);
  }
  String getLastLetterOfSurname() {
    return _teacherSurname.isNotEmpty
        ? _teacherSurname[_teacherSurname.length - 1]
        : '';
  }

  // Асинхронна функція, що викликає Future-повертаючі generic методи
  Future<void> processLecturesAsync(String word) async {
    try {
      // Отримати лекцію з мінімальною кількістю студентів
      Lecture? minLecture =
          await lectures.findMinByAsyncValue((l) => l.studentCount);
      print("Async: Лекція з мінімальною кількістю студентів:");
      print(minLecture);

      // Отримати список тем з певним словом
      List<Lecture> filteredLectures =
          await lectures.filterAsync((l) => l.topic.toLowerCase().contains(word.toLowerCase()));
      print("\nAsync: Список тем, що містять слово '$word':");
      for (var lecture in filteredLectures) {
        print("- ${lecture.topic}");
      }
    } catch (e) {
      print("Сталася помилка при асинхронній обробці: $e");
    }
  }
}

void main() async {
  Course course = Course("Об'єктно-орієнтоване програмування", "Петренко");
  course.addLecture(Lecture("2025-10-01", "Вступ до Dart", 35));
  course.addLecture(Lecture("2025-10-05", "Класи та об'єкти у Dart", 28));
  course.addLecture(Lecture("2025-10-10", "Списки та колекції", 22));
  course.addLecture(Lecture("2025-10-12", "Обробка помилок у Dart", 30));

  // Виклик асинхронної функції
  await course.processLecturesAsync("Dart");

  // Остання літера у прізвищі викладача
  print(
      "\nОстання літера у прізвищі викладача: ${course.getLastLetterOfSurname()}");
}
